#!/usr/bin/perl -w
# tries to reduce the number of includes in KDE source files
# (c) 2001 Dirk Mueller <mueller@kde.org>

# declaration of useful subroutines
sub find_fixable_sources ($);
sub find_removable_includes ($);
sub remove_include ($$$);
sub replace_include ($$$);
sub fix_duplicates($);
sub fix_compat_includes($);

# some global variables
$verbose = 0; # turns on debugging
$modify  = 0;  # if 1 it should try to fix the files as well

$cppExt     = "(cpp|cc|cxx|C|c\\+\\+)";
#$hExt       = "(h|H|hh|hxx|hpp|h\\+\\+)";

# list of compat headers. scroll down ... much of boring stuff here..
%compatmap = (
 'qapp.h'            => 'qapplication.h'          ,

);


# now it starts to get interesting again

sub find_fixable_sources ($)
{
  # for now I grep the directory (requires srcdir==builddir)
  # actually it should read the Makefile and
  # find the _SOURCES / _OBJECTS tags that are put there by
  # automake and am_edit, but thats an excercise to the reader ;-)

  my ( $dir ) = @_;

  opendir (DIR, "$dir") || die "Couldn't read '$dir'\n";
  my @sources = grep { /^.*\.$cppExt$/o } readdir(DIR);
  closedir(DIR);
  
  print "found sources: [ " . join(' ', @sources) . " ] in $dir\n" if ($verbose);

  # prefix them with $dir
  my @retsources = ();
  foreach $source(@sources) {
    push @retsources, "$dir/$source";
  }
  
  return @retsources;
}

sub find_removable_includes ($)
{
  my $srcfile = shift @_;
  open(SRC, "< $srcfile") || die "couldn't open '$srcfile'\n";
  
  my @includes = ();

  # we skip all inludes that are somehow ifdefed

  my $cpplevel = 0;
  while (<SRC>) {
    if ($_ =~ m/^\#if/) {
      $cpplevel = $cpplevel + 1;
      next;
    }
    if ($_ =~ m/^\#endif/) {
      $cpplevel = $cpplevel - 1;
      next;
    }
    if ($cpplevel == 0 && $_ =~ m/^\#include\s*[\"<]([qk]\S*\.h)[\">]\S*/) {
      push @includes, $1;
      next;
    }
  }
  close SRC;

  print "No fixable includes found in $srcfile\n" if ($verbose and not @includes);
  print "found includes: [ " . join(' ', @includes) . " ]\n" if ($verbose and @includes);

  return @includes;
}

# first parameter: srcfile
# second parameter: include to remove
# third parameter is the duplicate level: this include is removed $level times
sub remove_include ($$$)
{
  my $srcfile = shift @_;
  my $include = quotemeta(shift @_);
  my $level = shift @_;

  die "$srcfile is not read/writeable!\n" if( ! -r $srcfile || ! -w $srcfile);
  open(I, "< $srcfile") or die "couldn't open '$srcfile'\n";
  my @contents = <I>;
  close(I);

  # ok, CPU time doesn't count so we do it the lazy way
  # we should remove the last occurence of the include in the
  # file because in case its a duplicate removing the first
  # one could make a difference. 
  my @revcontents = reverse @contents;
  @contents = ();

  # we skip all inludes that are somehow ifdefed
  # note the logic is reversed because it operates
  # on reversed lines :)
  my $cpplevel = 0;
  foreach $line (@revcontents) {
    if ($line =~ m/^\#if/) {
      $cpplevel = $cpplevel - 1;
      push @contents, $line;
      next;
    }

    if ($line =~ m/^\#endif/) {
      $cpplevel = $cpplevel + 1;
      push @contents, $line;
      next;
    }

    if ($cpplevel == 0 && $level > 0 && $line =~ m/^\#include\s*[\"<]$include[\">]\S*/) {
      print "HAH! found $include to remove in $srcfile!\n" if($verbose);
      $level = $level - 1;
      # skipping the line..
      next;
    }

    push @contents, $line;
  }

  # now we have the fixed contents in @contents, although in wrong order
  open(O, "> $srcfile") || die "couldn't open '$srcfile' for writing\n";
  print O reverse @contents;
  close (O);
}

# first parameter: srcfile
# second parameter: include to replace
# third parameter the include file to replace it with
sub replace_include ($$$)
{
  my $srcfile = shift @_;
  my $include = quotemeta(shift @_);
  my $destinclude = shift @_;

  die "$srcfile is not read/writeable!\n" if( ! -r $srcfile || ! -w $srcfile);
  open(I, "< $srcfile") or die "couldn't open '$srcfile'\n";
  my @contents = <I>;
  close(I);

  # ok, CPU time doesn't count so we do it the lazy way
  # we should remove the last occurence of the include in the
  # file because in case its a duplicate removing the first
  # one could make a difference. 
  my @revcontents = reverse @contents;
  @contents = ();

  # we skip all inludes that are somehow ifdefed
  # note the logic is reversed because it operates
  # on reversed lines :)
  my $cpplevel = 0;
  foreach $line (@revcontents) {
    if ($line =~ m/^\#if/) {
      $cpplevel = $cpplevel - 1;
      push @contents, $line;
      next;
    }

    if ($line =~ m/^\#endif/) {
      $cpplevel = $cpplevel + 1;
      push @contents, $line;
      next;
    }

    if ($cpplevel == 0 && $line =~ m/^\#include\s*[\"<]$include[\">]\S*/) {
      print "HAH! found $include to replace in $srcfile!\n" if($verbose);
      $line =~ s/(\#include\s*[\"<])$include([\">]\S*)/$1$destinclude$2/;
    }

    push @contents, $line;
  }

  # now we have the fixed contents in @contents
  open(O, "> $srcfile") || die "couldn't open '$srcfile' for writing\n";
  print O reverse @contents;
  close (O);
}

sub fix_duplicates($)
{
  my $srcfile = shift @_;

  my @includes = &find_removable_includes($srcfile);

  my %inclMap = ();

  # initialize
  foreach $include (@includes) {
    $inclMap{$include} = 0;
  }
  
  # count number of occurences
  foreach $include (@includes) {
    $inclMap{$include} = $inclMap{$include} + 1;
  }
  
  # check for duplicates
  foreach $include (keys %inclMap) {
    next if $inclMap{$include} <= 1;
    
    print "$srcfile: duplicate level ". $inclMap{$include} .": ". $include ."\n";

    &remove_include($srcfile, $include, $inclMap{$include} - 1) if($modify);
  }
}

sub fix_compat_includes($)
{
  my $srcfile = shift @_;

  my @includes = &find_removable_includes($srcfile);

  my %inclMap = ();

  # initialize
  foreach $include (@includes) {
    $inclMap{$include} = 0;
  }
  
  # count number of occurences
  foreach $include (@includes) {
    $inclMap{$include} = $inclMap{$include} + 1;
  }
  
  # check for compat headers
  foreach $include (keys %inclMap) {
    if( defined $compatmap{$include}) {
      print "$srcfile: compat header: $include, to be replaced by ". $compatmap{$include} ."\n";
      &replace_include($srcfile, $include, $compatmap{$include}) if($modify);
    }
  }
}


# here is the main logic

# first generate a list of subdirectories
@dirlist = (".");
foreach $dir ( @dirlist ) {
 opendir (DIR, "$dir") || warn "Couldn't read '$dir'";
 my $subdir = "";
 while( $subdir = readdir(DIR)) {
   next if ($subdir =~ /^\..*/);
   push @dirlist, "$dir/$subdir" if ( -d "$dir/$subdir");
 }
 closedir(DIR);
}

# now iterate over all subdirs
foreach $dir(@dirlist) {
  @sources = &find_fixable_sources($dir);

  foreach $file(@sources) {
    print "Checking: $file\n" if($verbose);
    &fix_compat_includes($file);
    &fix_duplicates($file);

    print "\n" if ($verbose);
  }
}


