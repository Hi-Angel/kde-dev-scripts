#!/usr/bin/perl -w
# Script to handle building KDE from Subversion.  All of the configuration is
# stored in the file ~/.kdesvn-buildrc.
#
# Please also see the documentation that should be included with this program,
# in doc.html
#
# Copyright (c) 2003, 2004, 2005 Michael Pyne. <michael.pyne@kdemail.net>
# Home page: http://grammarian.homelinux.net/kdecvs-build/
#
# You may use, alter, and redistribute this software under the terms
# of the GNU General Public License, v2 (or any later version).
#
# TODO: It would be better to have lockfiles in each directory as it's
#       being updated, instead of having one big lock for the script.

use strict;
use warnings;
use Fcntl;    # For sysopen constants
use POSIX 'strftime';

# Some global variables
# Remember kids, global variables are evil!  I only get to do this
# because I'm an adult and you're not! :-P
# Options that start with a # will replace values with the same name,
# if the option is actually set.
my %global_opts = (
    "apidox"              => "",
    "apply-qt-patches"    => "",
    "binpath"             => "/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin",
    "build-dir"           => "build",
    "build-system-only"   => "",
    "checkout-only"       => "",
    "configure-flags"     => "--enable-debug=full --cache-file=$ENV{HOME}/.kdesvn-conf-cache",
    "colorful-output"     => 1, # Use color by default.
    "cxxflags"            => "-g -pipe -march=i686",
    "debug"               => "",
    "dest-dir"            => '${MODULE}', # single quotes used on purpose!
    "do-not-compile"      => "",
    "install-after-build" => "1", # Default to true
    "inst-apps"           => "",
    "kdedir"              => "$ENV{HOME}/kde",
    "libpath"             => "",
    "log-dir"             => "log",
    "make-install-prefix" => "",  # Some people need sudo
    "make-options"        => "-j2",
    "manual-build"        => "",
    "manual-update"       => "",
    "module-base-path"    => "",  # Used for tags and branches
    "niceness"            => "10",
    "no-svn"              => "",
    "no-rebuild-on-fail"  => "",
    "pretend"             => "",
    "qtdir"               => "$ENV{HOME}/kdesvn/build/qt-copy",
    "reconfigure"         => "",
    "recreate-configure"  => "",
    "refresh-build"       => "",
    "revision"            => 0,
    "set-env"             => { }, # Hash of environment vars to set
    "source-dir"          => "$ENV{HOME}/kdesvn",
    "stop-on-failure"     => "",
    "svn-server"          => "svn://anonsvn.kde.org/home/kde",
    "unsermake-options"   => "--compile-jobs=2 -p",
    "unsermake-path"      => "unsermake",
    "use-unsermake"       => "1", # Default to true now, we may need a blacklist
);

my %package_opts; # Holds module-specific options.
my %ignore_list;  # List of packages to refuse to include in the build list.
my @update_list;  # List of modules to update/checkout.
my @build_list;   # List of modules to build.
my @failed_list;  # List of modules that failed to update.
my @install_fail; # List of modules that failed to install.
my $install_flag; # True if we're in install mode.
my $BUILD_ID;     # Used by logging subsystem to create a unique log dir.
my $LOG_DATE;     # Used by logging subsystem to create logs in same dir.
my @rcfiles = ("./kdesvn-buildrc", "$ENV{HOME}/.kdesvn-buildrc2");

# Colors
my ($RED, $GREEN, $YELLOW, $NORMAL, $BOLD) = ("") x 5;

# Subroutine definitions

# I swear Perl must be the only language where the docs tell you to use a
# constant that you'll never find exported without some module from CPAN.
sub PRIO_PROCESS()
{
    return 0;
}

# Subroutine to handle removing the lock file upon receiving a signal
sub quit_handler
{
    print "Signal received, terminating.\n";
    finish(5);
}

# Subroutine which returns true if pretend mode is on.  Uses the prototype
# feature so you don't need the parentheses to use it.
sub pretending()
{
    return get_option('global', 'pretend');
}

# Subroutine which returns true if debug mode is on.  Uses the prototype
# feature so you don't need the parentheses to use it.
sub debugging()
{
    return get_option('global', 'debug');
}

# I'm lazy and would rather write in shorthand for the colors.  This sub
# allows me to do so. Put it right up top to stifle Perl warnings.
sub clr($)
{
    my $str = shift;

    $str =~ s/g\[/$GREEN/g;
    $str =~ s/]/$NORMAL/g;
    $str =~ s/y\[/$YELLOW/g;
    $str =~ s/r\[/$RED/g;
    $str =~ s/b\[/$BOLD/g;

    return $str;
}

# Subroutine that returns the path of a file used to output the results of the
# build process.  It accepts one parameter, which changes the kind of file
# returned.  If the parameter is set to 'existing', then the file returned is
# the latest file that exists, or undef if no log has been created yet.  This
# is useful for the --resume mode.  All other values will return the name if a
# file that does not yet exist.
#
# All files will be stored in the log directory.
sub get_output_file
{
    my $logdir;
    my $mode;
    $mode = shift or $mode = '';
    my $fname;

    print "get_output_file in mode $mode\n" if debugging;

    if ($mode eq 'existing')
    {
        # There's two ways of finding the old file.  Searching backwards with
        # valid combinations of the date and build id, or just reading in the
        # name from a known file or location.  Since the latter option is much
        # easier, that's what I'm going with.  Note that this depends on the
        # latest symlink being in place.
        $logdir = get_subdir_path ('global', 'log-dir');
        $fname = "$logdir/latest/build-status";
        print "Old build status file is $fname\n" if debugging;

        return "" if not -e $fname or not -r _;

        return $fname;
    }

    # This call must follow the test above, because it changes the 'latest'
    # symlink leading to failures later.
    $logdir = get_log_dir('global');
    $fname = "$logdir/build-status";
    print "Build status file is $fname\n" if debugging;
    return $fname;
}

# Subroutine to retrieve a subdirecty path for the given module.
# First parameter is the name of the module, and the second
# parameter is the option key (e.g. build-dir or log-dir).
sub get_subdir_path
{
    my $module = shift;
    my $option = shift;
    my $dir = get_option($module, $option);

    # If build-dir starts with a slash, it is an absolute path.
    return $dir if $dir =~ /^\//;

    # If it starts with a tilde, expand it out.
    if ($dir =~ /^~/)
    {
        $dir =~ s/^~/$ENV{'HOME'}/;
    }
    else
    {
        # Relative directory, tack it on to the end of $kdesvn.
        my $kdesvndir = get_kdesvn_dir();
        $dir = "$kdesvndir/$dir";
    }

    return $dir;
}

# Subroutine to return the name of the destination directory for the checkout
# and build routines.  Based on the dest-dir option.  The return value will be
# relative to the src/build dir.  The user may use the '$MODULE' or '${MODULE}'
# sequences, which will be replaced by the name of the module in question.
#
# The first parameter should be the module name.
sub get_dest_dir
{
    my $module = shift;
    my $dest_dir = get_option($module, 'dest-dir');

    $dest_dir =~ s/(\${MODULE})|(\$MODULE\b)/$module/g;

    return $dest_dir;
}

# Convienience subroutine to get the source root dir.
sub get_kdesvn_dir
{
    return get_option ('global', 'source-dir');
}

# Subroutine to return the appropriate SVN URL for a given module, based on
# the user settings.  For example, 'kdelibs' -> https://svn.kde.org/home/kde/trunk/KDE/kdelibs
sub svn_module_url
{
    my $module = shift;
    my $svn_server = get_option($module, 'svn-server');
    my $branch = get_option($module, 'module-base-path');
    
    $branch = 'trunk/KDE' unless $branch;
    $branch =~ s/^\/*//; # Eliminate / at beginning of string.
    $branch =~ s/\/*$//; # Likewise at the end.
    
    # The following modules are in /trunk, not /trunk/KDE.  There are others,
    # but there are the important ones.  The hash is associated with the value
    # 1 so that we can do a boolean test by looking up the module name.
    my %non_trunk_modules = (
       'extragear' => 1,
       'kdenonbeta' => 1,
       'kdesupport' => 1,
       'koffice' => 1,
       'playground' => 1,
       'qt-copy' => 1,
       'valgrind' => 1,
       'KDE' => 1,
       'kdereview' => 1,
       'www' => 1,
       'l10n' => 1,
    );

    my $module_root = $module;
    $module_root =~ s/\/.*//; # Remove everything after the first slash

    $branch = 'trunk' if $non_trunk_modules{$module_root};

    # Remove trailing slashes.
    $svn_server =~ s/\/*$//;

    return "$svn_server/$branch/$module";
}

# Convienience subroutine to return the build directory for a module. Use
# this instead of get_subdir_path because this special-cases modules for you,
# such as qt-copy.
# TODO: From what I hear this hack is no longer necessary.  Investigate this.
sub get_build_dir
{
    my $module = shift;

    # It is the responsibility of the caller to append $module!
    return get_kdesvn_dir() if ($module eq 'qt-copy') and not get_option('qt-copy', 'use-qt-builddir-hack');
    return get_subdir_path($module, 'build-dir');
}

# Subroutine to return a list of the different log directories that are used
# by the different modules in the script.
sub get_all_log_directories
{
    my @module_list = keys %package_opts;
    my %log_dict;

    unshift @module_list, "global";
    $log_dict{get_subdir_path($_, 'log-dir')} = 1 foreach @module_list;

    print "Log directories are ", join (", ", keys %log_dict), "\n" if debugging;
    return keys %log_dict;
}

# Subroutine to determine the build id for this invocation of the script.  The
# idea of a build id is that we want to be able to run the script more than
# once in a day and still retain each set of logs.  So if we run the script
# more than once in a day, we need to increment the build id so we have a
# unique value.  This subroutine sets the global variable $BUILD_ID and
# $LOG_DATE for use by the logging subroutines.
sub setup_logging_subsystem
{
    my $min_build_id = "00";
    my $date = strftime "%F", localtime; # ISO 8601 date
    my @log_dirs = get_all_log_directories();

    for (@log_dirs)
    {
        my $id = "01";
        $id++ while -e "$_/$date-$id";

        # We need to use a string comparison operator to keep 
        # the magic in the ++ operator.
        $min_build_id = $id if $id gt $min_build_id;
    }

    $LOG_DATE = $date;
    $BUILD_ID = $min_build_id;

    print "\$LOG_DATE = $LOG_DATE\n" if debugging;
    print "\$BUILD_ID = $BUILD_ID\n" if debugging;
}

# Convienience subroutine to return the log directory for a module.
# It also creates the directory and manages the 'latest' symlink.
#
# Returns undef on an error, or the name of the directory otherwise.
sub get_log_dir
{
    my $module = shift;
    my $logbase = get_subdir_path($module, 'log-dir');
    my $logpath = "$logbase/$LOG_DATE-$BUILD_ID/$module";

    $logpath = "$logbase/$LOG_DATE-$BUILD_ID" if $module eq 'global';
    print "Log dir for $module is $logpath\n" if debugging;

    if (not -e $logpath and not pretending and not super_mkdir($logpath))
    {
        print "Unable to create log directory $logpath!\n";
        print "\t$!\n";
        return undef;
    }

    # Add symlink to the directory.
    if (not pretending)
    {
        unlink("$logbase/latest") if -l "$logbase/latest";
        system('ln', '-s', "$logbase/$LOG_DATE-$BUILD_ID", "$logbase/latest");
    }

    return $logpath;
}

# This function returns true if the given option doesn't make sense with the
# given module.
# blacklisted($module, $option)
sub blacklisted
{
    my ($module, $option) = @_;
    my @unsermake_ban_list = qw/kde-common qt-copy kdebindings/; # Known to not work.

    if ($option eq 'use-unsermake')
    {
        for my $i (@unsermake_ban_list)
        {
            return 1 if $i eq $module;
        }
    }

    return 0;
}

# This subroutine returns an option value for a given module.  Some
# globals can't be overridden by a module's choice.  If so, the
# module's choice will be ignored, and a warning will be issued.
#
# Option names are case-sensitive!
#
# First parameter: Name of module
# Second paramenter: Name of option
sub get_option
{
    my $module = shift;
    my $option = shift;
    my $defaultQtCopyArgs = '-qt-gif -plugin-imgfmt-mng -thread -no-exception -debug -dlopen-opengl -plugin-sql-sqlite';

    # These options can't override globals
    if ($option eq "source-dir" ||
        $option eq "svn-server" ||
        $option eq "qtdir" ||
        $option eq "libpath" ||
        $option eq "binpath" ||
        $option eq "kdedir" ||
        $option eq "pretend" ||
        $module eq 'global')
    {
        return $global_opts{"#$option"} if exists $global_opts{"#$option"};
        return $global_opts{$option};
    }

    # Don't even try this
    return 0 if blacklisted($module, $option);

    my $ref = $package_opts{$module};

    # Check for a sticky option
    return $$ref{"#$option"} if exists $$ref{"#$option"};

    # Next in order of precedence
    if (defined $global_opts{"#$option"} and not 
        ($module eq 'qt-copy' and $option eq 'configure-flags'))
    {
        return $global_opts{"#$option"} if defined $global_opts{"#$option"};
    }

    # No sticky options left.
    # Configure flags and CXXFLAGS are appended to the global option
    if (($module ne 'qt-copy' && $option eq 'configure-flags')
        || $option eq 'cxxflags')
    {
        my $value = $global_opts{$option};

        if(defined $$ref{$option})
        {
            my $modvalue = $$ref{$option};
            $value .= " $modvalue";
        }

        return $value;
    }

    # As always qt-copy has to be difficult
    if ($module eq 'qt-copy' and $option eq 'configure-flags')
    {
        return $defaultQtCopyArgs if not defined $$ref{$option};
        return $$ref{$option};
    }

    # Everything else overrides the global, unless of course it's not set.
    # If we're reading for global options, we're pretty much done.
    return $$ref{$option} if defined $$ref{$option};
    return $global_opts{$option};
}

# Subroutine used to handle the checkout-only option.  It handles
# updating subdirectories of an already-checked-out module.
# First parameter is the module, all remaining parameters are subdirectories
# to check out.
#
# Returns 0 on success, non-zero on failure.
sub update_module_subdirectories
{
    my $module = shift;
    my $result;

    # If we have elements in @path, download them now
    for my $dir (@_)
    {
        print clr "\tUpdating g[$dir]\n";
        $result = run_svn($module, "svn-up-$dir", [ 'svn', 'up', $dir ]);
        return $result if $result;
    }

    return 0;
}

# Returns true if a module has a base component to their name (e.g. KDE/,
# extragear/, or playground).  Note that modules that aren't in trunk/KDE
# don't necessary meet this criteria (e.g. kdereview is a module itself).
sub has_base_module
{
    my $module = shift;

    return $module =~ /^(extragear|playground|KDE)(\/[^\/]+)?$/;
}

# Subroutine to return the directory that a module will be stored in.
# NOTE: The return value is a hash. The key 'module' will return the final
# module name, the key 'path' will return the full path to the module. The
# key 'fullpath' will return their concatenation.
# For example, with $module == 'KDE/kdelibs', and no change in the dest-dir
# option, you'd get something like:
# {
#   'path'     => '/home/user/kdesvn/KDE',
#   'module'   => 'kdelibs',
#   'fullpath' => '/home/user/kdesvn/KDE/kdelibs'
# }
# If dest-dir were changed to e.g. extragear-multimedia, you'd get:
# {
#   'path'     => '/home/user/kdesvn',
#   'module'   => 'extragear-multimedia',
#   'fullpath' => '/home/user/kdesvn/extragear-multimedia'
# }
# First parameter is the module.
# Second parameter is either source or build.
sub get_module_path_dir
{
    my $module = shift;
    my $type = shift;
    my $destdir = get_dest_dir($module);
    my $srcbase = get_kdesvn_dir();
    $srcbase = get_build_dir($module) if $type eq 'build';

    my $combined = "$srcbase/$destdir";

    # Remove dup //
    $combined =~ s/\/+/\//;

    my @parts = split(/\//, $combined);
    my %result = ();
    $result{'module'} = pop @parts;
    $result{'path'} = join('/', @parts);
    $result{'fullpath'} = "$result{path}/$result{module}";

    return %result;
}

sub get_fullpath
{
    my ($module, $type) = @_;
    my %pathinfo = get_module_path_dir($module, $type);

    return $pathinfo{'fullpath'};
}

# Checkout a module that has not been checked out before, along with any
# subdirectories the user desires.
# The first parameter is the module to checkout (including extragear and
# playground modules), all remaining parameters are subdirectories of the
# module to checkout.
# Returns 0 on success, non-zero on failure.
sub checkout_module_path
{
    my ($module, @path) = @_;
    my %pathinfo = get_module_path_dir($module, 'source');
    my $result;
    my @args;

    if (not -e $pathinfo{'path'} and not super_mkdir($pathinfo{'path'}))
    {
        print clr "Unable to create path r[$pathinfo{path}]!\n";
        return 1;
    }

    chdir($pathinfo{'path'});

    push @args, ('svn', 'co');
    push @args, '-N' if scalar @path;
    push @args, svn_module_url($module);
    push @args, $pathinfo{'module'};

    print clr "Checking out g[$module]\n";
    $result = run_svn($module, 'svn-co', \@args);
    return $result if $result;

    chdir($pathinfo{'module'}) if scalar @path;

    return update_module_subdirectories($module, @path);
}

# Update a module that has already been checked out, along with any
# subdirectories the user desires.
# The first parameter is the module to checkout (including extragear and
# playground modules), all remaining parameters are subdirectories of the
# module to checkout.
# Returns 0 on success, non-zero on failure.
sub update_module_path
{
    my ($module, @path) = @_;
    my $fullpath = get_fullpath($module, 'source');
    my $result;
    my @args;

    chdir $fullpath;

    switch_repo_url(svn_module_url($module));

    push @args, ('svn', 'up');
    push @args, '-N' if scalar @path;

    print clr "Updating g[$module]\n";
    $result = run_svn($module, 'svn-up', \@args);
    return $result if $result;

    # If the admin dir exists and is a soft link, remove it so that svn can
    # update it if need be.  The link will automatically be re-created later
    # in the process if necessary by the build functions.
    unlink ("$fullpath/admin") if -l "$fullpath/admin";

    return update_module_subdirectories($module, @path);
}

# Subroutine to run a command with redirected STDOUT and STDERR.  First parameter
# is name of the log file (relative to the log directory), and the
# second parameter is a reference to an array with the command and
# its arguments
sub log_command
{
    my $pid;
    my $module = shift;
    my $filename = shift;
    my @command = @{(shift)};
    my $logdir = get_log_dir($module);

    if (debugging)
    {
        print "log_command(): Module $module, Command: ", join(' ', @command), "\n";
    }

    if (pretending)
    {
        print clr "\tWould have run g[", join (' ', @command), clr "]\n";
        return 0;
    }

    if ($pid = fork)
    {
        # Parent
        waitpid $pid, 0;

        # If the module fails building, set an internal flag in the module
        # options with the name of the log file containing the error message.
        $package_opts{$module}{'#error-log-file'} = "$logdir/$filename.log" if $?;

        return $?;
    }
    else
    {
        # Child
        if (not defined $logdir or not -e $logdir)
        {
            # Error creating directory for some reason.
            print "\tLogging to std out due to failure creating log dir.\n";
        }

        # Redirect stdout and stderr to the given file.
        if (not debugging)
        {
# Comment this out because it conflicts with make-install-prefix
#            open (STDIN, "</dev/null");
            open (STDOUT, ">$logdir/$filename.log") or do {
                print "Error opening $logdir/$filename.log for logfile.\n";
                print "\t$!\n";
            };
        }
        else
        {
            open (STDOUT, "|tee $logdir/$filename.log") or do {
                print "Error opening pipe to tee command.\n";
                print "\t$!\n";
            };
        }

        # Make sure we log everything.
        open (STDERR, ">&STDOUT");

        exec (@command) or do {
            print "Unable to exec ", join (' ', @command), "!\n";
            print "\t$!\n";
            print "\tPlease check your binpath setting, PATH is currently $ENV{PATH}\n";
            return $?;
        };
    }
}

# Subroutine to run make/unsermake with redirected STDOUT and STDERR,
# and to process the percentage in unsermake (-p). First parameter
# is name of the log file (relative to the log directory), and the
# second parameter is a reference to an array with the command and
# its arguments.
# Returns 0 on success, non-zero on failure.
sub run_make_command
{
    my $pid;
    my $module = shift;
    my $filename = shift;
    my @command = @{(shift)};
    my $logdir = get_log_dir($module);
    my $isunsermake = $command[0] =~ 'unsermake';

    # Don't print ANSI characters if we're not on a tty.  Also,  automake
    # doesn't support printing output status.
    if (!$isunsermake or not -t STDERR)
    {
        return log_command($module, $filename, \@command);
    }

    if (debugging)
    {
        print "run_make_command(): Module $module, Command: ", join(' ', @command), "\n";
    }

    if (pretending)
    {
        print clr "\tWould have run g[", join (' ', @command), clr "]\n";
        return 0;
    }

    $pid = open(CHILD, '-|');
    if ($pid)
    {
        my $last = -1;
        while (<CHILD>)
        {
            chomp;
            if (debugging)
            {
                print $_;
            }
            elsif (/([0-9]+)% (creating|compiling|linking)/)
            {
                print STDERR "\r$1% \e[K" unless ($1 == $last);
                $last = $1;
            }
        }
        close(CHILD);
        print STDERR "\r\e[K\n";

        # If the module fails building, set an internal flag in the module
        # options with the name of the log file containing the error message.
        $package_opts{$module}{'#error-log-file'} = "$logdir/$filename.log" if $?;

        return $?;
    }
    else
    {
        # Child
        if (not defined $logdir or not -e $logdir)
        {
            # Error creating directory for some reason.
            print "\tLogging to std out due to failure creating log dir.\n";
        }

        open (STDOUT, "|tee $logdir/$filename.log") or do {
            print "Error opening pipe to tee command.\n";
            print "\t$!\n";
        };

        # Make sure we log everything.
        open (STDERR, ">&STDOUT");

        exec (@command) or do {
            print "Unable to exec ", join (' ', @command), "!\n";
            print "\t$!\n";
            print "\tPlease check your binpath setting, PATH is currently $ENV{PATH}\n";
            return $?;
        };
    }
}

# Subroutine to determine if the given subdirectory of a module can actually be
# built or not.  For instance, /admin can never be built, and the /kalyptus subdir
# of kdebindings can't either.
sub is_subdir_buildable
{
    my ($module, $dir) = @_;

    return 0 if $dir eq 'admin';
    return 0 if $dir eq 'kalyptus' and $module eq 'kdebindings';
    return 1;
}

# Subroutine to run the make command with the arguments given by the passed
# list.  The first argument of the list given must be the module that we're
# making.  The second argument is the "try number", used in creating the log
# file name.
#
# Returns 0 on success, non-zero on failure (shell script style)
sub safe_make (@)
{
    my ($module, $trynumber, $apidox, @args) = @_;
    my $opts;
    my $logdir = get_log_dir($module);
    my $checkout_dirs = get_option($module, "checkout-only");
    my @dirs = split(' ', $checkout_dirs);
    my $installing = $trynumber eq 'install';
    my $make = 'make';

    if (get_option($module, 'use-unsermake'))
    {
        $make = get_option('global', 'unsermake-path');
        $opts = get_option($module, 'unsermake-options');
    }
    else
    {
        $opts = get_option($module, 'make-options');
    }

    # Add make-options to the given options, as long as we're not installing
    # If we are installing, unsermake seems to assume that the options are a
    # make target, and parallel builds don't help with installing anyways.
    unshift (@args, split(' ', $opts)) unless $installing;

    my $description;

    # Check if we're installing
    if($installing)
    {
        print "Prepending install options, apidox: $apidox.\n" if debugging;

        $description = $apidox ? "API Documentation" : clr "g[$module]";
        unshift @args, $make, $apidox ? 'install-apidox' : 'install';
        unshift @args, split(' ', get_option ($module, 'make-install-prefix'));

        print "\tInstalling $description.\n";
    }
    else
    {
        $description = "Building API Documentation";
        $description = "Compiling, attempt $trynumber" unless $apidox;

        push @args, 'apidox' if $apidox;
        unshift @args, $make;

        print "\t$description...\n";
    }

    push (@dirs, "") if scalar @dirs == 0;
    for my $subdir (@dirs)
    {
        # Some subdirectories shouldn't have make run within them.
        next unless is_subdir_buildable($module, $subdir);

        my $logname = "build-$trynumber";
        if ($installing)
        {
            $logname = $apidox ? 'install-apidox' : 'install';
        }

        if ($subdir ne '')
        {
            $logname = $installing ? "install-$subdir" : "build-$subdir-$trynumber";
            next if $apidox; # Don't built apidox in a subdirectory

            print $installing ? "\tInstalling " : "\tBuilding ", clr "subdirectory g[$subdir]\n";
        }

        my %pathinfo = get_module_path_dir($module, 'build');
        my $builddir = "$pathinfo{fullpath}/$subdir";
        $builddir =~ s/\/*$//;

        if (pretending)
        {
            $opts = join(' ', @args);
            print clr "\tWould have switched directory to y[$builddir]\n";
            print clr "\tWould have run g[$opts > $logdir/$logname]\n";

            next;
        }

        chdir ($builddir);

        my $result = run_make_command ($module, $logname, \@args );
        return $result if $result;
    };

    return 0;
}

# Subroutine to add a variable to the environment, but ONLY if it
# is set. First parameter is the variable to set, the second is the
# value to give it.
sub setenv
{
    my ($var, $val) = @_;

    return unless $val;

    if(pretending)
    {
        print clr "\tWould have set g[$var]=y[$val].\n";
    }
    else
    {
        $ENV{$var} = $val;
    }
}

# Display a message to the user regarding their relative lack of
# ~/.kdesvn-buildrc, and point them to some help.  We will continue using a
# default set of options.
sub no_config_whine
{
    my $searched = join("\n    ", @rcfiles);
    my $homepage = "http://grammarian.homelinux.net/kdesvn-build/";

    print <<"HOME";
Unable to open configuration file!
We looked for:
    $searched

kdesvn-build will continue using a default set of options.  These options may
not apply to you, so feel free to visit the kdesvn-build homepage

$homepage

and use the configuration file generator to guide you through the process of
creating a config file to customize your kdesvn-build process.

HOME
}

# This subroutine assigns the appropriate options to %package_opts and the
# update and build lists to build a default set of modules.
sub setup_default_modules()
{
    @update_list = qw(qt-copy arts kdesupport kdelibs kdebase kdeartwork
                      kdemultimedia kdepim kdeutils kdegraphics kdegames
                      kdetoys kdeedu kdeaddons);
    @build_list = @update_list;

    %package_opts = ( ) unless %package_opts;
    for my $i (@update_list) {
        if (not exists $package_opts{$i})
        {
            $package_opts{$i} = { }; # Set up defaults
            $package_opts{$i}{'set-env'} = { };
        }
    }

    # Setup default options for qt-copy
    $package_opts{'qt-copy'} = {
        'conf-flags' => q(-system-zlib -qt-gif -system-libjpeg -system-libpng
                          -plugin-imgfmt-mng -thread -no-exceptions -debug
                          -dlopen-opengl),
        'apply-qt-patches' => 'true',
        'use-qt-builddir-hack' => 'true',
        'use-unsermake' => 0,
    };
}

# This subroutine reads in the settings from the user's configuration
# file.
sub read_options
{
    # The options are stored in the file $rcfile
    my $success = 0;
    my $rcfile;
    for $rcfile (@rcfiles)
    {
        if (open CONFIG, "<$rcfile")
        {
            $success = 1;
            last;
        }
    }

    if (not $success)
    {
        if(scalar @rcfiles == 1)
        {
            # This can only happen if the user uses --rc-file, if we fail to
            # load the file, we need to fail to load.
            print <<EOM;
Unable to open config file $rcfiles[0] ($!)

Script stopping here since you specified --rc-file on the command line to
load $rcfiles[0] manually.  If you wish to run the script with no configuration
file, leave the --rc-file option out of the command line.
EOM
            exit 1;
        }

        no_config_whine();
        setup_default_modules();
        return;
    }

    my ($option, $flags, $modulename);

    # Read in global settings
    OUTER: while (<CONFIG>)
    {
        s/#.*$//;       # Remove comments
        next if (/^\s*$/); # Skip blank lines

        # First command in .kdesvn-buildrc should be a global
        # options declaration, even if none are defined.
        if (not /^global\s*$/)
        {
            print "Invalid configuration file: $rcfile.\n";
            print "Expecting global settings section!\n";
            exit 1;
        }

        # Now read in each global option
        while (<CONFIG>)
        {
            s/#.*$//;       # Remove comments
            next if /^\s*$/;   # Skip blank lines
            last OUTER if /^end\s+global/; # Stop

            # The option is the first word, followed by the
            # flags on the rest of the line.  The interpretation
            # of the flags is dependant on the option.
            ($option, $flags) = /^\s*([-a-zA-Z0-9]+)\s+(.*)$/;

            # Replace tildes with home directory.
            1 while ($flags =~ s/(^|:)~/$1$ENV{'HOME'}/);
            $flags = 0 if $flags =~ /^false$/;

            if ($option ne 'set-env')
            {
                $global_opts{$option} = $flags;
            }
            else
            {
                my ($var, @values) = split(/\s/, $flags);
                $global_opts{'set-env'}{$var} = join(' ', @values);
            }
        }
    }

    my $using_default = 1;
    %package_opts = ( ) unless %package_opts;

    # Now read in module settings
    while (<CONFIG>)
    {
        s/#.*$//;       # Remove comments
        next if (/^\s*$/); # Skip blank lines

        if (not /^module\s+[-\/\.\w]+\s*$/)
        {
            print "Invalid configuration file $rcfile!\n";
            print "Expecting a start of module section.\n";
            print "Global settings will be retained.\n";
        }

        # Get modulename (has dash, dots, slashes, or letters/numbers)
        ($modulename) = /^module\s+([-\/\.\w]+)\s*$/;

        # Don't build default modules if user has their own wishes.
        if ($using_default)
        {
            $using_default = 0;
            @update_list = @build_list = ( );
        }

        if (not exists $package_opts{$modulename})
        {
            $package_opts{$modulename} = { }; # Set up defaults
            $package_opts{$modulename}{'set-env'} = { };
        }

        while (<CONFIG>)
        {
            s/#.*$//;       # Remove comments
            next if (/^\s*$/); # Skip blank lines
            last if (/^end\s+module/);

            # Split into option and its flags.
            ($option, $flags) = /^\s*([-a-zA-Z0-9]+)\s+(.*?)\s*$/;

            # Replace tildes with home directory.
            1 while ($flags =~ s/(^|:|=)~\//$1$ENV{'HOME'}\//);
            $flags = 0 if $flags eq 'false';
            if ($option ne 'set-env')
            {
                $package_opts{$modulename}{$option} = $flags;
            }
            else
            {
                my ($var, @values) = split(/\s/, $flags);
                $package_opts{$modulename}{'set-env'}{$var} = join(' ', @values);
            }
        }

        # Done reading options, add this module to the update list
        push (@update_list, $modulename) unless exists $ignore_list{$modulename};

        # Add it to the build list, unless the build is only
        # supposed to be done manually.
        if (not get_option ($modulename, 'manual-build') and not exists $ignore_list{$modulename})
        {
            push (@build_list, $modulename);
        }
    }

    close CONFIG;

    # If the user doesn't ask to build any modules, build a default set.
    # The good question is what exactly should be built, but oh well.
    setup_default_modules() if $using_default;
}

# This subroutine reads the set-env option for a given module and initializes
# the environment based on that setting.
sub setup_module_environment
{
    my $module = shift;
    my ($key, $value);

    # Let's see if the user has set env vars to be set.
    my $env_hash_ref = get_option($module, 'set-env');
    while (($key, $value) = each %{$env_hash_ref})
    {
        setenv($key, $value);
    }
}

# Subroutine to initialize some environment variable for building
# KDE from Subversion.  Change this section if a dependency changes later.
sub initialize_environment
{
    $ENV{"WANT_AUTOMAKE"} = "1.7";
    $ENV{"WANT_AUTOCONF_2_5"} = "1";
    $ENV{"PATH"} = get_option ('global', 'binpath');

    my $svnserver = get_option ('global', 'svn-server');

    my $pc_path = $ENV{'PKG_CONFIG_PATH'};
    if ($ENV{'PKG_CONFIG_PATH'})
    {
        $ENV{'PKG_CONFIG_PATH'} = get_option('global', 'kdedir') . "/lib/pkgconfig:$pc_path";
    }
    else
    {
        $ENV{'PKG_CONFIG_PATH'} = get_option('global', 'kdedir') . "/lib/pkgconfig";
    }

    if(-t STDOUT and get_option('global', 'colorful-output'))
    {
        $RED = "\e[31m";
        $GREEN = "\e[32m";
        $YELLOW = "\e[33m";
        $NORMAL = "\e[0m";
        $BOLD = "\e[1m";
    }

    # Set the process priority
    setpriority PRIO_PROCESS, 0, get_option('global', 'niceness');

    setup_module_environment ('global');
}

# Subroutine to get a list of modules to install, either from the command line
# if it's not empty, or based on the list of modules successfully built.
sub get_install_list
{
    my @install_list;

    if ($#ARGV > -1)
    {
        @install_list = @ARGV;
        @ARGV = ();
    }
    else
    {
        # Get list of built items from $logdir/latest/build-status
        my $logdir = get_subdir_path('global', 'log-dir');

        if (not open BUILTLIST, "<$logdir/latest/build-status")
        {
            print "Can't determine what modules have built.  You must\n";
            print "specify explicitly on the command line.\n";
            exit (1); # Don't finish, no lock has been taken.
        }

        while (<BUILTLIST>)
        {
            chomp;
            if (/Succeeded/)
            {
                # Clip to everything before the first colon.
                s/^([^:]+):.*/$1/;
                push @install_list, $_;
            }
        }

        close BUILTLIST;
    }

    return @install_list;
}

# Print out an error message, and a list of modules that match that error
# message.  It will also display the log file name if one can be determined.
# The message will be displayed all in uppercase, with PACKAGES prepended, so
# all you have to do is give a descriptive message of what this list of
# packages failed at doing.
sub output_failed_module_list($@)
{
    my ($message, @fail_list) = @_;
    $message = uc $message; # Be annoying

    print "Message is $message\n" if debugging;
    print "\tfor ", join(', ', @fail_list), "\n" if debugging;

    if (scalar @fail_list > 0)
    {
        my $homedir = $ENV{'HOME'};
        my $logfile;

        print clr "\nr[b[<<<  PACKAGES $message  >>>]\n";

        for (@fail_list)
        {
            $logfile = $package_opts{$_}{'#error-log-file'};
            $logfile = "No log file" unless $logfile;
            $logfile =~ s|$homedir|~|;

            print clr "r[$_] - g[$logfile]\n";
        }
    }
}

# This subroutine extract the value from options of the form --option=value,
# which can also be expressed as --option value.  The first parameter is the
# option that the user passed to the cmd line (e.g. --prefix=/opt/foo), and
# the second parameter is a reference to the list of command line options.
# The return value is the value of the option (the list might be shorter by
# 1, copy it if you don't want it to change), or undef if no value was
# provided.
sub extract_option_value($\@)
{
    my ($option, $options_ref) = @_;

    if ($option =~ /=/)
    {
        my @value = split(/=/, $option);
        shift @value; # We don't need the first one, that the --option part.

        return undef if (scalar @value == 0);

        # If we have more than one element left in @value it's because the
        # option itself has an = in it, make sure it goes back in the answer.
        return join('=', @value);
    }

    return undef if scalar @{$options_ref} == 0;
    return shift @{$options_ref};
}

# Utility subroutine to handle setting the environment variable type of value.
# Returns true (non-zero) if this subroutine handled everything, 0 otherwise.
# The first parameter should by the reference to the hash with the 'set-env'
# hash ref, second parameter is the exact option to check, and the third
# option is the value to set that option to.
sub handle_set_env
{
    my ($href, $option, $value) = @_;

    return 0 if $option !~ /^#?set-env$/;

    my ($var, @values) = split(/\s/, $value);

    $$href{$option} = ( ) unless exists $$href{$option};
    $$href{$option}{$var} = join(' ', @values);

    return 1;
}

# Sets the option for the given module to the given value.  If the data for the
# module doesn't exist yet, it will be defined starting with a default value.
# First parameter: module to set option for (or 'global')
# Second parameter: option name (Preceded by # for a sticky option)
# Third parameter: option value
# Return value is void
sub set_option
{
    my ($module, $option, $value) = @_;

    # Set global options
    if ($module eq 'global')
    {
        return if handle_set_env(\%global_opts, $option, $value); 

        $global_opts{$option} = $value;

        return;
    }

    # Set module options
    if (not exists $package_opts{$module})
    {
        $package_opts{$module} = {
            'set-env' => { }
        };
    }

    return if handle_set_env($package_opts{$module}, $option, $value);
    $package_opts{$module}{$option} = $value;
}

# Subroutine to process the command line arguments.  Any arguments so
# processed will be removed from @ARGV.
# The arguments are generally documented in doc.html now.
# NOTE: Don't call finish() from this routine, the lock hasn't been obtained.
# NOTE: The options have not been loaded yet either.  Any option which
# requires more than rudimentary processing should set a flag for later work.
sub process_arguments
{
    my $arg;
    my $author = "Michael Pyne <michael.pyne\@kdemail.net>";
    my $version = "kdesvn-build 0.96\n";
    my @argv;

    while ($_ = shift @ARGV)
    {
        SWITCH: {
            /^(-v)|(--version)$/ && do { print $version; exit; };
            /^--author$/         && do { print "$author\n"; exit; };
            /^(-h)|(--?help)$/   && do {
                print <<DONE;
$version
This script automates the download, build, and install process for KDE (using
Subversion).

It is recommended that your first setup a .kdesvn-buildrc file in your home
directory.  Please visit http://grammarian.homelinux.net/kdesvn-build/ for
information on how to write the file, or consult the sample file which should
have been included with this program.  If you don't setup a .kdesvn-buildrc,
a default set of options will be used, which a few modules to be built by
default.

After setting up .kdesvn-buildrc, you can run this program from either the
command-line or from cron.  It will automatically download the modules from
Subversion, create the build system, and configure and make the modules you
tell it to.  If you\'d like, you can use this program to install KDE as well,
if you\'re building KDE for a single user.  Note that kdesvn-build will try
by default to install the modules.

Basic synopsis, after setting up .kdesvn-buildrc:
\$ kdesvn-build [package names] (Download, build, and install KDE)

If you don\'t specify any particular package names, then your settings
in .kdesvn-buildrc will be used.  If you DO specify a package name, then
your settings will still be read, but the script will try to build/install
the package regardless of .kdesvn-buildrc

Copyright (c) 2003, 2004, 2005 $author
The script is distributed under the terms of the GNU General Public License
v2, and includes ABSOLUTELY NO WARRANTY!!!

Options:
    --no-svn             Skip contacting the Subversion server.
    --no-build           Skip the build process.
    --no-install         Don't automatically install after build.

    --svn-only           Update from Subversion only (Identical to --no-build at 
                         this point).
    --build-only         Build only, don't perform updates or install.

    --rc-file=<filename> Read configuration from filename instead of default.
    --debug              Activates debug mode.
    --pretend (or -p)    Don't actually contact the Subversion server, run make,
                         or create/delete files and directories.  Instead,
                         output what the script would have done.
    --nice=<value>       Allows you to run the script with a lower priority
                         The default value is 10 (lower priority by 10 steps).
    --prefix=/kde/path   This option is a shortcut to change the setting for
                         kdedir from the command line.  It implies
                         --reconfigure.
    --color
    --no-color           Add (or remove) color from the output.

    --resume             Tries to resume the make process from the last time
                         the script was run, without performing the Subversion
                         update.
    --resume-from=<pkg>  Starts building from the given package, without
                         performing the Subversion update.
    --revision (or -r)=<rev> Forces update to revision <rev> from Subversion.

    --refresh-build      Start the build from scratch.
    --reconfigure        Run configure again, but don't clean the build
                         directory or re-run make -f Makefile.cvs.
    --recreate-configure Run make -f Makefile.cvs again to redo the configure
                         script.
    --no-rebuild-on-fail Don't try to rebuild a module from scratch if it
                         failed building and we didn't already try to build it
                         from scratch.
    --build-system-only  Create the build infrastructure, but don't actually
                         perform the build.
    --install            Try to install the packages passed on the command
                         line, or all packages in ~/.kdesvn-buildrc that don't
                         have manual-build set.  Building and Subversion updates are
                         not performed.
    --<option>=          Any unrecognized options are added to the global
                         configuration, overriding any value that may exist.
    --<module>,<option>= Likewise, this allows you to override any module
                         specific option from the command line.

    --help               You\'re reading it. :-)
    --author             Output the author(s)\'s name.
    --version            Output the program version.

You can get more help by reading the included HTML documentation, or going
online to http://grammarian.homelinux.net/kdesvn-build/
DONE
                # We haven't done any locking... no need to finish()
                #  Avoids log-dir errors due to having not
                #  read_options() and setup_logging_subsystem().
                exit 0;
            };

            /^--install$/ && do {
                $install_flag = 1;
                last SWITCH;
            };

            /^--no-svn$/ && do {
                $global_opts{'#no-svn'} = 1;
                last SWITCH;
            };

            /^--no-install$/ && do {
                $global_opts{'#install-after-build'} = 0;
                last SWITCH;
            };

            /^--debug$/ && do {
                $global_opts{'#debug'} = 1;
                last SWITCH;
            };

            /^--reconfigure$/ && do {
                $global_opts{'#reconfigure'} = 1;
                last SWITCH;
            };

            /^--recreate-configure$/ && do {
                $global_opts{'#recreate-configure'} = 1;
                last SWITCH;
            };

            /^--color$/ && do {
                $global_opts{'#colorful-output'} = 1;
                last SWITCH;
            };

            /^--no-color$/ && do {
                $global_opts{'#colorful-output'} = 0;
                last SWITCH;
            };

            /^--no-build$/ && do {
                $global_opts{'#manual-build'} = 1;
                last SWITCH;
            };

            # Although equivalent to --no-build at this point, someday the
            # script may interpret the two differently, so get ready now.
            /^--svn-only$/ && do {      # Identically to --no-build
                $global_opts{'#manual-build'} = 1;
                last SWITCH;
            };

            # Don't run Subversion or install
            /^--build-only$/ && do {
                $global_opts{'#no-svn'} = 1;
                $global_opts{'#install-after-build'} = 0;
                last SWITCH;
            };

            /^--build-system-only$/ && do {
                $global_opts{'#build-system-only'} = 1;
                last SWITCH;
            };

            /^--rc-file(=.*)?$/ && do {
                my $rcfile = extract_option_value($_, @ARGV);
                if (not $rcfile)
                {
                    print "You must specify a filename to use as the config file!\n";
                    exit 8;
                }

                @rcfiles = ( $rcfile );

                last SWITCH;
            };

            /^--prefix/ && do {
                my $prefix = extract_option_value($_, @ARGV);
                if (not $prefix)
                {
                    print "No prefix selected with the --prefix option.\n";
                    exit 8;
                }

                $global_opts{'#kdedir'} = $prefix;
                $global_opts{'#reconfigure'} = 1;

                last SWITCH;
            };

            /^--nice(=.*)?$/ && do {
                my $niceness = extract_option_value($_, @ARGV);

                if($niceness)
                {
                    $global_opts{'#niceness'} = $niceness;
                }
                else
                {
                    print "You need to specify a value for the --nice option\n";
                    exit 8;
                }

                last SWITCH;
            };

            /^--ignore-modules$/ && do {
                # We need to keep read_options() from adding these modules to
                # the build list, taken care of by ignore_list.  We then need
                # to remove the modules from the command line, taken care of
                # by the @ARGV = () statement;
                my @options = ();
                foreach (@ARGV)
                {
                    if (/^-/)
                    {
                        push @options, $_;
                    }
                    else
                    {
                        $ignore_list{$_} = 1;

                        # the pattern match doesn't work with $_, alias it.
                        my $module = $_;
                        @argv = grep (!/^$module$/, @argv);
                    }
                }
                @ARGV = @options;

                last SWITCH;
            };

            /^(--pretend)|(-p)$/ && do {
                $global_opts{'#pretend'} = 1;
                last SWITCH;
            };

            /^--refresh-build$/ && do {
                $global_opts{'#refresh-build'} = 1;
                last SWITCH;
            };

            /^(--revision|-r)(=.*)?$/ && do {
                my $revision = extract_option_value($_, @ARGV);
                if (not $revision)
                {
                    print "No revision selected with the --revision option.\n";
                    exit 8;
                }

                $global_opts{'#revision'} = $revision;

                last SWITCH;
            };

            /^--resume-from(=.*)?$/ && do {
                $_ = extract_option_value($_, @ARGV);
                if (not $_)
                {
                    print "You must pass a module to resume from to the --resume-from option!\n";
                    exit 7;
                }

                if (defined $global_opts{'#resume'})
                {
                    print "WARNING: Don't pass both --resume and --resume-from\n";
                    delete $global_opts{'#resume'};
                }

                $global_opts{'#resume-from'} = $_;
                $global_opts{'#no-svn'} = 1;
                last SWITCH;
            };

            /^--resume$/ && do {
                if (defined $global_opts{'#resume'})
                {
                    print "WARNING: Don't pass both --resume and --resume-from\n";
                    delete $global_opts{'#resume-from'};
                }

                $global_opts{'#resume'} = 1;
                $global_opts{'#no-svn'} = 1;
                last SWITCH;
            };

            /^--/ && do {
                # First let's see if they're trying to override a global option.
                my ($option) = /^--([-\w\d\/]+)/;
                my $value = extract_option_value($_, @ARGV);

                if (exists $global_opts{$option})
                {
                    # Global option
                    set_option('global', "#$option", $value);
                }
                else
                {
                    # Module specific option.  The module options haven't been
                    # read in, so we'll just have to assume that the module the
                    # user passes actually does exist.
                    my ($module, $option) = /^--([\w\/-]+),([-\w\d\/]+)/;

                    if (not $module)
                    {
                        print "Unknown option $_\n";
                        exit 8;
                    }

                    set_option($module, "#$option", $value);
                }

                last SWITCH;
            };

            /^-/ && do { print "WARNING: Unknown option $_\n"; last SWITCH; };

            push @argv, $_; # Reconstruct correct @ARGV
        }
    }

    @ARGV = @argv;
}

# Subroutine to try to get a lock on the script's lockfile to prevent
# more than one script from updating KDE Subversion at once.
# The value returned depends on the system's open() call.  Normally 0
# is failure and non-zero is success (e.g. a file descriptor to read).
# TODO: This could be improved to not fight over the lock when the scripts are
# handling separate tasks.
sub get_lock
{
    my $lockfile = "$ENV{HOME}/.kdesvn-lock";
    my $result = sysopen LOCKFILE, $lockfile, O_WRONLY | O_CREAT | O_EXCL;

    # Very wordy way of saying to return if result == 0
    return $result unless $result;

    # Install signal handlers to ensure that the lockfile gets closed.
    # There is a race condition here, but at worst we have a stale lock
    # file, so I'm not *too* concerned.
    $SIG{'HUP'} = \&quit_handler;
    $SIG{'INT'} = \&quit_handler;
    $SIG{'QUIT'} = \&quit_handler;
    $SIG{'ABRT'} = \&quit_handler;
    $SIG{'TERM'} = \&quit_handler;
    $SIG{'PIPE'} = \&quit_handler;
}

# Subroutine to free the lock allocated by get_lock()
sub close_lock
{
    my $lockfile = "$ENV{HOME}/.kdesvn-lock";

    close LOCKFILE;
    unlink $lockfile;
}

sub adjust_update_list
{
    my $list_ref = shift;
    my $build_ref = shift;

    # Check to see if the user has requested for one of the modules to be
    # built is using unsermake.  If so, we need to check if kdenonbeta is
    # already supposed to be checked out.  If so, we need to make sure that
    # unsermake is present in any checkout-only directives, and if not, we need
    # to add kdenonbeta/unsermake to the checkout list.
    my @unsermake_list;
    my %existance_hash;

    @unsermake_list = grep (get_option ($_, 'use-unsermake'), @{$list_ref});

    # Create a hash to lookup quickly whether a given module is being built.
    # I must have looked this up somewhere, I have no idea how it works. :(
    @existance_hash{@{$build_ref}} = 1 x @{$build_ref};

    my $unsermake_needed = 0;
    for (@unsermake_list)
    {
        if ($existance_hash{$_})
        {
            $unsermake_needed = 1;
            last;
        }
    }

    if ($unsermake_needed)
    {
        if (scalar grep (/^kdenonbeta$/, @{$list_ref}) == 0)
        {
            print "Adding kdenonbeta/unsermake to build.\n" if pretending;

            # kdenonbeta isn't being downloaded by the user.
            unshift (@{$list_ref}, 'kdenonbeta');
            $package_opts{'kdenonbeta'} = {
                'manual-build'   => 'true',
                'checkout-only'  => 'unsermake',
                '#suppress-auto-admin' => 1,
            };
        }
        elsif (get_option ('kdenonbeta', 'checkout-only') and
            get_option ('kdenonbeta', 'checkout-only') !~ /\bunsermake\b/)
        {
            # kdenonbeta is being checked out, but the user has
            # excluded unsermake.
            $package_opts{'kdenonbeta'}->{'checkout-only'} .= " unsermake";
            $package_opts{'kdenonbeta'}->{'#suppress-auto-admin'} = 1;
        }
    }
}

# Subroutine to get the list of Subversion modules to update.  Returned
# as a list.  Parse the command-line arguments first.
sub get_update_list
{
    return @ARGV unless $#ARGV == -1;

    my @return_list;
    for (@update_list)
    {
        push @return_list, $_ if not get_option($_, "manual-update");
    }

    return @return_list;
}

# Subroutine to get the list of Subversion modules to build.  Returned
# as a list.  A module will not be built if manual-build is set
# in the module's options.  The command-line arguments should have been
# parsed first.
#
# This subroutine will handle the --resume and --resume-from options.
sub get_build_list
{
    my $resume_point;
    my $autoresuming;

    # We check explicity for sticky options here since they can only be
    # set from the command line.
    if (get_option('global', '#manual-build'))
    {
        if (get_option('global', '#resume') || get_option('global',
            '#resume-from'))
        {
            print "I'm confused, you enabled --no-build and --resume.\n";
            print "Skipping the build process.\n";
        }

        return ();
    }

    if (get_option ('global', '#resume'))
    {
        if (scalar @ARGV > 0)
        {
            print "Ignoring modules specified on command line because --resume was set.\n";
        }

        # Try to determine location of last existing status file.
        my $status_fname = get_output_file('existing');
        if (not $status_fname)
        {
            print "Unable to open status file from last run, can't resume!\n";
            return ();
        }

        my ($line, $oldline);
        open STATUS_FILE, "<$status_fname" or do {
            print "Can't open $status_fname, so I can't resume!\n";
            print "\t$!\n";
            return ();
        };

        while ($line = <STATUS_FILE>)
        {
            $oldline = $line;
        }

        close STATUS_FILE;

        if (not defined $oldline)
        {
            # Hmm, empty file?
            print "Unable to read information from resume status file.\n";
            print "It's probably empty, but there's no way to resume!\n";
            return ();
        }

        chomp $oldline;
        print "The last success line is $oldline\n" if debugging;

        ($resume_point = $oldline) =~ s/^([^:]+):.*/$1/;
        print "Resuming at $resume_point\n" if debugging;
    }
    elsif (get_option ('global', '#resume-from'))
    {
        $resume_point = get_option ('global', '#resume-from');
        $autoresuming = 1;
    }

    if ($resume_point)
    {
        my $resume_found = 0;

        # Pop stuff off of the list until we hit the resume point.
        while (scalar @build_list > 0 and not $resume_found)
        {
            $resume_found = 1 if $build_list[0] eq $resume_point;

            # If we're doing an auto resume, pop off the last package read
            # from the file.  If we're doing resume from on the other hand,
            # I'm assuming the user intends to start with building that
            # package.
            shift @build_list unless $resume_found and $autoresuming;
        }

        return @build_list;
    }

    return @ARGV unless $#ARGV == -1;

    my @list;
    for (@build_list)
    {
        push @list, $_ unless get_option($_, 'manual-update');
    }

    return @list;
}

# Helper subroutine for debugging purposes.  Dumps all of the
# options which have been read in to %global_opts and %package_opts.
sub dump_options
{
    my ($item, $ref_item, $ref);
    my $c; # $c is a color variable to be used with clr()

    # Dump all of the global options
    print "Global options:\n";
    foreach $item (keys %global_opts)
    {
        # Put the first bracket in $c, otherwise some Perl systems break.
        $c = $item =~ /^#/ ? 'r[' : 'g[';

        if($item !~ /^#?set-env$/)
        {
            print clr "  ${c}$item] is \"y[$global_opts{$item}]\"\n";
        }
        else
        {
            my $setref = $global_opts{$item};

            foreach my $envitem (keys %{$setref})
            {
                print clr "  Set ${c}$envitem] to y[", $$setref{$envitem}, clr "]\n";
            }
        }
    }

    # Now dump the options for each module
    foreach $item (keys %package_opts)
    {
        print clr "\nOptions for module g[$item]:\n";
        my $ref = $package_opts{$item};

        foreach $ref_item (keys %{$package_opts{$item}})
        {
            # Put the first bracket in here, otherwise it breaks on some
            # Perl systems.
            $c = $ref_item =~ /^#/ ? 'r[' : 'g[';

            if($ref_item !~ /^#?set-env$/)
            {
                print clr "  ${c}$ref_item] is \"y[", $$ref{$ref_item}, clr "]\"\n";
            }
            else
            {
                # Dump the environment variables that will be set.
                my $setref = $$ref{$ref_item};

                foreach my $envitem (keys %{$setref})
                {
                    print clr "  Set env variable ${c}$envitem] to y[", $$setref{$envitem}, clr "]\n";
                }
            }
        }
    }
}

# Subroutine to unlink the given symlink if global-pretend isn't set.
sub safe_unlink
{
    if (pretending)
    {
        print "\tWould have unlinked ", shift, ".\n";
        return 1; # Return true
    }

    return unlink (shift);
}

# Subroutine to execute the system call on the given list if the pretend
# global option is not set.
sub safe_system(@)
{
    if (not pretending)
    {
        print clr "\tExecuting g[", join(" ", @_), clr "]\n";
        return system (@_) >> 8;
    }

    print clr "\tWould have run g[", join(' ', @_), clr "].\n";
    return 0; # Return true
}

# Helper subroutine to create a directory, including any parent
# directories that may also need created.
# Returns 0 on failure, non-zero on success
sub super_mkdir
{
    my $pathname = shift;
    my $temp;
    my @parts = split (/\//, $pathname);

    if (pretending)
    {
        print clr "\tWould have created g[$pathname]\n";
        return 1;
    }

    foreach (@parts)
    {
        $temp .= "$_/";

        next if -e $temp;
        return 0 if not mkdir ($temp);
    }

    return 1;
}

# Subroutine to remove a package from the package build list.  This
# is for use when you've detected an error that should keep the
# package from building, but you don't want to abort completely.
sub dont_build
{
    my $module = shift;

    print "Not building $module\n" if debugging;

    # Weed out matches of the module name
    @build_list = grep (!/^$module$/, @build_list);

    push @failed_list, $module;
}

# Subroutine to split a url into a protocol and host
sub split_url
{
    my $url = shift;
    my ($proto, $host) = ($url =~ m|([^:]*)://([^/]*)/|);

    return ($proto, $host);
}

# Subroutine to switch repos to a different one if necessary.
# First and only parameter is the new repo url
sub switch_repo_url
{
    my $svnpath = shift;
    my $oldurl = get_repo_url();
    my ($rootproto, $roothost) = split_url($svnpath);
    my ($repoproto, $repohost) = split_url(get_repo_url());

    if($repoproto ne $rootproto or $repohost ne $roothost)
    {
        print clr "y[Repository URL has changed, updating].\n";
        safe_system('svn', 'switch', '--relocate', "$oldurl", "$svnpath");
    }
}

# Subroutine to update a list of Subversion modules.  The first
# parameter is a reference of a list of the modules to update.
# If the module has not already been checkout out, this subroutine
# will do so for you.
#
# Returns 0 on success, non-zero on error.
sub handle_updates
{
    my $update_ref = shift;
    my $kdesvn = get_kdesvn_dir();
    my $svnroot = get_option ('global', 'svn-server');
    my $result = 0;
    my $module;

    # No reason to print out the text if we're not doing anything.
    return 0 if get_option ('global', 'no-svn');

    print "<<<  Updating Subversion Directories  >>>\n\n";

    if (not -e $kdesvn)
    {
        print "KDE Subversion download directory doesn't exist, creating.\n";
        if (not super_mkdir ($kdesvn))
        {
            print clr "Unable to make directory r[$kdesvn]!\n$!\n";
            @build_list = (); # Clear out the build list, since we can't build.
            $install_flag = 0; # Can't install either.
            return 1;
        }
    }

    foreach $module (@{$update_ref})
    {
        my $fullpath = get_fullpath($module, 'source');

        if (not exists $package_opts{$module})
        {
            print clr "Unknown module y[$module], configure it in ~/.kdesvn-buildrc.\n";
            next;
        }

        next if get_option($module, 'no-svn');

        my @options = split(' ', get_option($module, 'checkout-only'));
        if (-e "$fullpath/.svn")
        {
            $result = update_module_path($module, @options);
        }
        else
        {
            $result = checkout_module_path($module, @options);
        }

        if ($result)
        {
            print clr "Error updating r[$module], removing from list of packages to build.\n";
            dont_build ($module);
        }

        print "\n";
    }

    print "<<<  Update Complete  >>>\n";
    return $result;
}

# Subroutine to run the qt-copy apply_patches script.  Assumes we're
# already in the right directory.  Returns 0 on success, non-zero on
# failure.
sub safe_apply_patches
{
    my %pathinfo = get_module_path_dir('qt-copy', 'build');
    my $builddir = "$pathinfo{fullpath}";

    if (pretending)
    {
        print clr "\tWould have run g[./apply_patches]\n";
        return 0;
    }

    print clr "\tg[Applying recommended Qt patches].\n";
    chdir ("$builddir");
    return (log_command('qt-copy', 'apply-patches', [ "./apply_patches" ]));
}

# Subroutine to run and log the configure command.  First parameter is the
# path to the configure script to run, the second parameter is a scalar
# containing all of the configure flags to apply
sub safe_configure
{
    my $module = shift;
    my $fullpath = get_fullpath($module, 'source');
    my $script = "$fullpath/configure";

    my @commands = split (/\s+/, get_option($module, 'configure-flags'));

    # Get the user's CXXFLAGS
    my $cxxflags = get_option ($module, 'cxxflags');
    setenv ('CXXFLAGS', $cxxflags);
    setenv ('DO_NOT_COMPILE', get_option ($module, 'do-not-compile'));

    if ($module ne 'qt-copy')
    {
        my $kdedir = get_option ('global', 'kdedir');
        push @commands, "CXXFLAGS=$cxxflags" if $cxxflags;
        push @commands, "--prefix=$kdedir";

        # We're special casing these modules because we're using the lndir
        # hack for them.
        if ($module eq 'kdebindings' or $module eq 'valgrind')
        {
            my %pathinfo = get_module_path_dir($module, 'build');
            $script = "$pathinfo{fullpath}/configure";
        }
    }
    else
    {
        my $qtdir = get_fullpath('qt-copy', 'build');

        if(not pretending)
        {
            # Copy the configure script to accept the GPL license.
            open CONFIG, "<$script";
            open NEWCONFIG, ">$qtdir/configure.new";
            while(<CONFIG>)
            {
                s/read acceptance/acceptance=yes/;
                print NEWCONFIG $_;
            }
            close NEWCONFIG;
            close CONFIG;
            chmod 0755, "$qtdir/configure.new";
        }

        $script = "$qtdir/configure.new";

        print clr "\tb[r[GPL license selected for Qt.  See] $fullpath/qt-copy/LICENSE.GPL\n";
    }

    print clr "\tRunning g[configure]...\n";
    unshift @commands, $script;

    if(pretending)
    {
        print clr "\tWould have run g[", join("' '", @commands), clr "]\n";
        return 0;
    }

    return log_command($module, "configure", \@commands);
}

# Subroutine to try and see if we've already tried to update kde-common
sub has_updated_kdecommon
{
    # Test fast case first.
    return 1 if get_option('global', '#has-checked-for-admin');

    # Double check that it wasn't in the update list.
    if (grep(/^(KDE\/)?kde-common$/, @update_list))
    {
        $global_opts{'#has-checked-for-admin'} = 1;
        return 1;
    }

    return 0;
}

# Subroutine to automatically create an admir dir for a module if it doesn't
# have one.  The first parameter is the module name.  It is assumed that we
# are already in the source directory, the current directory will not be
# changed.
#
# Returns boolean true on success, boolean false on failure.
#
# NOTE: This subroutine might try to call an svn update, as long as #no-svn
# isn't set.
sub create_admin_dir
{
    my $module = shift;
    my $fullpath = get_fullpath($module, 'source');

    # Don't bother if it's qt-copy, or if we've already got an admin
    # directory.
    return 1 if $module eq 'qt-copy';
    return 1 if -e "$fullpath/admin";

    # Find kde-common
    my $admindir = get_fullpath('kde-common', 'source') . '/admin';
    if (not -e $admindir)
    {
        $admindir = get_fullpath('KDE/kde-common', 'source') . '/admin';
    }

    if (not -e $admindir)
    {
        # Can't find kde-common, it's apparently not installed.
        if (not has_updated_kdecommon())
        {
            # We haven't tried downloading it, now would be a good time.
            print clr "Can't find y[kde-common], going to try downloading it.\n";

            if (get_option('global', 'no-svn'))
            {
                # Not allowed to update.
                print clr "r[!!] Updating has been blocked, can't get y[kde-common].\n";
                return 0;
            }

            # Checkout the directory.
            $admindir = get_fullpath('kde-common', 'source') . '/admin';
            if (pretending)
            {
                print clr "Would have checked out g[kde-common]\n";
            }
            elsif (checkout_module_path('kde-common', 'admin') != 0)
            {
                return 0;
            }
        }
    }

    chdir ($fullpath);
    return (safe_system("ln -s $admindir admin") == 0);
}

# Subroutine to create the build system for a module.  This involves making
# sure the directory exists and then running make -f Makefile.cvs.  This
# subroutine assumes that the module is already downloaded.
sub safe_create_build_system
{
    my $module = shift;
    my $fullpath = get_fullpath($module, 'source');
    my $builddir = get_fullpath($module, 'build');
    my $instapps = get_option($module, 'inst-apps');

    if (pretending)
    {
        print clr "\tWould have created g[$module]\'s build system.\n";
        return 0;
    }

    chdir ($fullpath);
    chdir ($builddir) if $module eq 'qt-copy' and get_option('qt-copy', 'use-qt-builddir-hack');

    # Check for admin dir, if it doesn't exist, create a softlink
    if (not create_admin_dir($module))
    {
        print clr "Unable to find /admin directory for y[$module], it probably\n";
        print "won't build.\n";
        # But continue anyways, because in this case I'm just not sure that it
        # won't work in the future. ;)
    }

    if ($module eq 'kdebindings' || $module eq 'valgrind')
    {
        # Use a slightly less effective method of builddir != srcdir for the
        # module, as it fails otherwise.
        chdir($builddir);

        # lndir is included with XFree86 and X.org
        if (log_command ($module, "lndir", [ "lndir", "$fullpath" ]))
        {
            print clr "\tUnable to setup special build system for r[$module].\n";
            return 1;
        }
    }

    if ($instapps)
    {
        open (INSTAPPS, ">inst-apps") or do {
            print clr "\tUnable to create inst-apps file for r[$module]!\n$!\n";
            return 1;
        };

        print INSTAPPS "$instapps\n";
        close INSTAPPS;
    }
    else
    {
        unlink ("$fullpath/inst-apps");
    }

    my $cmd_ref = [ 'make', '-f', 'Makefile.cvs' ];
    $cmd_ref = [ './autogen.sh' ] if $module eq 'valgrind';

    if (log_command ($module, "build-system", $cmd_ref))
    {
        print clr "\tUnable to create build system for r[$module]\n";
        return 1;
    }

    return 0;
}

# Subroutine to determine if a given module needs to have the build system
# recreated from scratch.
# If so, it returns boolean true.
sub needs_refreshed
{
    my $module = shift;
    my $builddir = get_fullpath($module, 'build');
    my $conf_file_key = "Makefile"; # File that exists after configure is run

    # Use a different file to indicate configure has been run for qt-copy
    $conf_file_key = "src/tools/qconfig.cpp" if $module eq 'qt-copy';

    if (debugging)
    {
        print "Build directory not setup for $module.\n" if not -e "$builddir";
        print ".refresh-me exists.\n" if -e "$builddir/.refresh-me";
        print "refresh-build option set.\n" if get_option($module, 'refresh-build');
        print "Can't find configure key file.\n" if not -e "$builddir/$conf_file_key";
    }

    return 1 if ((not -e "$builddir") ||
        (-e "$builddir/.refresh-me") ||
        get_option($module, "refresh-build") ||
        (not -e "$builddir/$conf_file_key"));

    return 0;
}

# Run the svn command.  This is a special subroutine so that we can munge the
# generated output to see what files have been added, and adjust the build
# according.
# First parameter is the module we're building.
# Second parameter is the filename to use for the log file.
# Third parameter is a reference to a list, which is the command ('svn') and all
#       of its arguments.
sub run_svn
{
    my ($module, $logfilename, $arg_ref) = @_;
    my %hash_count;
    my $result;
    my $force_refresh = 0;
    my $logdir = get_log_dir($module);

    my $revision = get_option('global', 'revision');
    if ($revision ne '0')
    {
        my @tmp = @{$arg_ref};

        # Insert after first two entries, deleting 0 entries from the
        # list.
        splice @tmp, 2, 0, '-r', $revision;
        $arg_ref = \@tmp;
    }

    # Do svn update.
    $result = log_command($module, $logfilename, $arg_ref);

    # There will be no result if we're pretending, so don't even
    # bother.
    return 0 if pretending;

    $logfilename = "$logdir/$logfilename.log";

    # We need to open the file and try to determine what the Subversion process
    # did.
    open SVN_LOG, "<$logfilename";
    while (<SVN_LOG>)
    {
        # Count updates and patches together.
        $hash_count{'updated'}++    if /^U /;
        $hash_count{'updated'}++    if /^P /;
        $hash_count{'added'}++      if /^A /;
        $hash_count{'removed'}++    if /^R /;
        $hash_count{'modified'}++   if /^M /;
        $hash_count{'conflicted'}++ if /^C /;

        # Check if we need to force a refresh.
        $force_refresh = 1 if /^A / and /Makefile\.am/;
        $force_refresh = 1 if /^[PAMU] / and /configure\.in\.in/;
    }

    close SVN_LOG;

    my %endings = (
        'updated'     => 'files were updated',
        '1updated'    => 'file was updated',
        'added'       => 'files were added',
        '1added'      => 'file was added',
        'removed'     => 'files were removed',
        '1removed'    => 'file was removed',
        'modified'    => 'files were modified',
        '1modified'   => 'file was modified',
        'conflicted'  => 'files had conflicts',
        '1conflicted' => 'file had conflicts',
    );

    my ($key, $value);
    while (($key, $value) = each %hash_count)
    {
        next unless $value > 0;
        my $ending_key = $value > 1 ? $key : ('1' . $key);
        my $ending = $endings{$ending_key};
        print "\t$value $ending.\n";
    }

    if ($force_refresh)
    {
        print "File(s) related to the build system were updated, forcing a refresh.\n";
        $package_opts{$module}{'refresh-build'} = 1;
        $package_opts{$module}{'#cancel-clean'} = 1;
    }

    return $result;
}

# Subroutine to clean the build system for the given module.  Works by
# recursively deleting the directory and then recreating it.  Returns
# 0 for failure, non-zero for success.
sub clean_build_system
{
    my $module = shift;
    my $moduledir = get_fullpath($module, 'source');
    my $builddir = get_fullpath($module, 'build');

    if (pretending) {
        print clr "\tWould have cleaned build system for g[$module].\n";
        return 1
    };

    if (not -e $moduledir)
    {
        print clr "\tUnable to clean build system for r[$module], it's not been checked out!\n";
        return 0;
    }

    # Clean qt-copy separately
    if ($module eq 'qt-copy')
    {
        if (get_option ('qt-copy', 'use-qt-builddir-hack'))
        {
            if (log_command ('qt-copy', 'clean-builddir', ['rm', '-rf', "$builddir"]))
            {
                print clr "Error refreshing r[qt-copy] builddir!\n";
                return 0;
            }
        }
        else
        {
            chdir ("$builddir");
            if (log_command ('qt-copy', 'clean', ['make', 'clean']))
            {
                print clr "r[WARNING]: Error cleaning r[qt-copy].\n";
            }
            unlink ("$builddir/.qmake.cache");
        }

        return 1;
    }
    elsif (-e "$builddir" &&
        safe_system ('rm', '-rf', "$builddir"))
    {
        # Remove build directory for normal module.
        print clr "\tUnable to unlink r[$builddir], skipping.\n";
        return 0; # False for this function.
    }

    # Now create the directory
    if (not -e "$builddir" and not super_mkdir ("$builddir"))
    {
        print clr "\tUnable to create directory r[$builddir], skipping.\n";
        return 0;
    }

    return 1;
}

# Subroutine to setup the build system in a directory.  The first parameter
# is the module name.  Returns boolean true on success, boolean false (0)
# on failure.
sub setup_build_system
{
    my $module = shift;
    my $fullpath = get_fullpath($module, 'source');
    my $builddir = get_fullpath($module, 'build');
    my $do_configure = get_option ($module, 'reconfigure');
    my $do_makeconf = get_option ($module, 'recreate-configure');

    if (needs_refreshed($module))
    {
        # The build system needs created, either because it doesn't exist, or
        # because the user has asked that it be completely rebuilt.
        print clr "\tPreparing build system for y[$module].\n";

        # Define this option to tell later functions that we tried to rebuild
        # this module.
        $package_opts{$module}->{'#was-rebuilt'} = 1;

        # Check to see if we're actually supposed to go through the cleaning
        # process.
        if (not $package_opts{$module}->{'#cancel-clean'} and
            not clean_build_system($module))
        {
            print clr "\tUnable to clean r[$module]!\n";
            return 0;
        }

        $do_makeconf = 1;
    }

    if ($module eq 'qt-copy' && get_option($module, 'use-qt-builddir-hack'))
    {
        # Copy qt-copy wholesale to the builddir, to simulate srcdir !=
        # builddir.  This could probably be converted to the lndir method
        # used for kdebindings and valgrind.
        if (log_command ('qt-copy', 'create-builddir', ['cp', '-af',
                         $fullpath, $builddir ]))
        {
            print clr "Error creating r[qt-copy] build system!\n";
            return 0;
        }
    }

    my $confpath = $module =~ /(valgrind|kdebindings)$/ ? $builddir : $fullpath;

    if ($do_makeconf or not -e "$confpath/configure")
    {
        print clr "\ty[Recreating configure script].\n";

        # Note this is the checkout directory, not the build directory
        # This will equal $builddir for qt-copy without qt-builddir-hack
        chdir ($fullpath);

        # Update the PATH and other important environment variables.
        update_module_environment ($module);

        if (safe_create_build_system ($module))
        {
            print "\tUnable to create configure system from checkout.\n";
            return 0;
        }

        $do_configure = 1;

        if (($module eq "qt-copy") && get_option($module, 'apply-qt-patches'))
        {
            # Run apply-patches script
            return 0 if safe_apply_patches ();
        }

        # Check to see if we're supposed to stop here
        return 1 if get_option ($module, 'build-system-only');
    }

    $do_configure = 1 if $module eq 'qt-copy' and not -e "$builddir/src/tools/qconfig.cpp";
    if ($do_configure || not -e "$builddir/Makefile")
    {
        if (not -e "$builddir" and not super_mkdir("$builddir"))
        {
            print clr "\tUnable to create build directory for r[$module]!!\n";
            return 0;
        }

        # Now we're in the checkout directory
        # So, switch to the build dir.
        # builddir is automatically set to the right value for qt-copy
        if (not chdir ("$builddir") and not pretending)
        {
            print clr "\tUnable to change directory to r[$builddir]!!\n";
            return 0;
        }

        # configure the module (sh script return value semantics)
        if (safe_configure ($module))
        {
            print clr "\tUnable to configure r[$module]!\n";
            return 0;
        }
    }

    return 1;
}

# Subroutine to setup the environment for a module.  First parameter is the name of
# the module to set the environment for
sub update_module_environment
{
    my $module = shift;
    my $kdedir = get_option ($module, 'kdedir');
    my $qtdir = get_option ($module, 'qtdir');
    my $path = join(':', "$qtdir/bin", "$kdedir/bin", get_option ($module, 'binpath'));
    my $libdir = join(':', "$qtdir/lib", "$kdedir/lib", get_option ($module, 'libpath'));

    # Set up the children's environment.  We use setenv since it
    # won't set an environment variable to nothing.  (e.g, setting
    # QTDIR to a blank string might confuse Qt or KDE.

    # Remove leading and trailing colons, just in case.
    # Also remove more than one colon.
    for ($path, $libdir)
    {
        s/^:*//;
        s/:*$//;
        s/:+/:/;
    }

    # Everyone loves unsermake.  It's a pity that not every module will compile with it.
    # Benjamin Meyer has an excellent article about speeding up distributed builds using
    # unsermake.  You should notice a much faster build using distcc, and
    # a slightly faster build even with only one CPU.
    if (get_option ($module, "use-unsermake"))
    {
        my $kdenonbeta = get_fullpath('kdenonbeta', 'source');
        $path = "$kdenonbeta/unsermake:$path";
    }
    else
    {
        setenv ("UNSERMAKE", "no");
    }

    setenv ('LD_LIBRARY_PATH', $libdir);
    setenv ('PATH', $path);
    setenv ('KDEDIR', $kdedir);
    setenv ('QTDIR', $qtdir);

    # Qt has several defines of its own.  Special case qt-copy for this
    # reason.
    setenv ("YACC", 'byacc -d') if ($module eq "qt-copy");

    # Read in user environment defines
    setup_module_environment ($module);
}

# Subroutine to make sure the build directory for a module is setup.
# The module to setup is the first parameter.
#
# Returns boolean true on success, boolean false on failure.
sub setup_build_directory
{
    my $module = shift;
    my $builddir = get_build_dir($module);

    if (not -e "$builddir")
    {
        print clr "\ty[$builddir] doesn't exist, creating.\n";
        if (not super_mkdir ("$builddir"))
        {
            print clr "\tUnable to create r[$builddir]!\n$!\n";
            return 0;
        }
    }

    return 1;
}

# Subroutine to return a string suitable for displaying an elapsed time, (like
# a stopwatch) would.  The first parameter is the number of seconds elapsed.
sub prettify_seconds
{
    my $elapsed = $_[0];
    my $str = "";
    my ($days,$hours,$minutes,$seconds,$fraction);

    $fraction = int (100 * ($elapsed - int $elapsed));
    $elapsed = int $elapsed;

    $seconds = $elapsed % 60;
    $elapsed = int $elapsed / 60;

    $minutes = $elapsed % 60;
    $elapsed = int $elapsed / 60;

    $hours = $elapsed % 24;
    $elapsed = int $elapsed / 24;

    $days = $elapsed;

    $seconds = "$seconds.$fraction" if $fraction;

    my @str_list;

    for (qw(days hours minutes seconds))
    {
        # Use a symbolic reference without needing to disable strict refs.
        # I couldn't disable it even if I wanted to because these variables
        # aren't global or localized global variables.
        my $value = eval "return \$$_;";
        my $text = $_;
        $text =~ s/s$// if $value == 1; # Make singular

        push @str_list, "$value $text" if $value or $_ eq 'seconds';
    }

    # Add 'and ' in front of last element if there was more than one.
    push @str_list, ("and " . pop @str_list) if (scalar @str_list > 1);

    $str = join (", ", @str_list);
    print "Time from $_[0] was $str.\n" if debugging;

    return $str;
}

# Subroutine to determine if a given module can run make apidox.  Returns
# boolean true if make apidox can be run.
sub make_apidox_supported
{
    my $module = shift;

    return $module =~ /^(KDE\/)?(kde(base|games|graphics|libs|pim|velop)|koffice)$/;
}

# Subroutine to build a given module.  The module to build is the first
# parameter.  The second and third paramaters is the ordinal number of the
# module being built (1 == first module, 2 == second, etc.), and the total
# number of modules being built respectively.
#
# Returns boolean false on failure, boolean true on success.
sub build_module
{
    my $module = shift;
    my $cur_module_num = shift;
    my $total_module_num = shift;
    my $apidox = shift;
    my $builddir = get_fullpath($module, 'build');
    my $trynumber = 1;

    # Do some tests to make sure we're ready to build.
    if (not exists $package_opts{$module})
    {
        print clr "Unknown module y[$module], configure it in ~/.kdesvn-buildrc.\n";
        return 0;
    }

    update_module_environment($module);

    if($module eq 'qt-copy' and $builddir ne get_option('global', 'qtdir'))
    {
        my $qtpath = $builddir;
        $qtpath =~ s/$ENV{HOME}/~/;
        print clr <<EOF;

b[y[!!] You're building qt-copy, but QTDIR isn't set to use qt-copy!
b[y[!!] Please set your qtdir variable in the global section of your
b[y[!!] ~/.kdesvn-buildrc to g[$qtpath]

EOF
    }

    my $start_time = time;
    while (not defined $package_opts{$module}->{'#was-rebuilt'})
    {
        print clr "Building g[$module] ($cur_module_num/$total_module_num)\n";
        return 0 if not setup_build_directory($module);
        return 0 if not setup_build_system($module);
        return 1 if (get_option ($module, 'build-system-only'));

        if (safe_make ($module, $trynumber))
        {
            # Build failed
            # There are several reasons why the build could fail.  If we're
            # using unsermake for this module, then perhaps we just need to
            # run make again.  After that, we can re-run make -f Makefile.cvs
            # and etc and then try make again.  If that STILL doesn't work, we
            # can try rm -rf $builddir/$module and rebuild.

            my $elapsed = prettify_seconds (time - $start_time);
            my $was_rebuilt = defined $package_opts{$module}{'#was-rebuilt'};
            $start_time = time;

            ++$trynumber;

            if ($trynumber > 3 or $was_rebuilt or get_option ($module, 'no-rebuild-on-fail'))
            {
                # Well we tried, but it isn't going to happen.
                print clr "\n\tUnable to build y[$module]!\n";
                print clr "\tTook g[$elapsed].\n";
                return 0;
            }

            if ($trynumber == 2)
            {
                # Just try again
                print clr "\n\ty[Couldn't build, going to try again just in case].\n";
                print clr "\tTook g[$elapsed].\n";
                next;
            }

            # Don't remove the old modules, but re-run make -f
            # Makefile.cvs and configure.
            print "\n\tStill couldn't build, recreating build system (builddir is safe).\n";
            print "\tTook $elapsed of time.\n";
            $package_opts{$module}->{'#cancel-clean'} = 1;
            $package_opts{$module}->{'refresh-build'} = 1;

            # Loop again
        }
        else
        {
            # Build succeeded, build docs if necessary
            my $apidox_result = 0;
            my $build_apidox = make_apidox_supported($module) && get_option($module, 'apidox');
            if ($build_apidox)
            {
                $apidox_result = safe_make ($module, $trynumber, 1);
                print "\tCouldn't build API Documentation\n" if $apidox_result;
            }

            my $elapsed = prettify_seconds (time - $start_time);
            my $do_install = get_option($module, 'install-after-build');

            print clr "\tBuild done after g[$elapsed].\n";
            if ($do_install)
            {
                handle_install($module, 0);
                handle_install($module, 1) if $build_apidox and $apidox_result == 0;
            }
            else
            {
                print clr "\tSkipping install for y[$module]\n";
            }

            last; # Don't forget to exit the loop!
        }
    }

    return 1;
}

# Subroutine to handle the build process.
# First parameter is a reference of a list containing the packages
# we are to build.
# If the packages are not already checked-out and/or updated, this
# subroutine WILL NOT do so for you.
#
# This subroutine assumes that the $kdesvn directory has already been
# set up.  It will create $builddir if it doesn't already exist.
#
# If $builddir/$module/.refresh-me exists, the subroutine will
# completely rebuild the module.
#
# Returns 0 for success, non-zero for failure.
sub handle_build
{
    my @fail_list;
    my @build_done;
    my $build_ref = shift;
    my $kdesvn = get_kdesvn_dir();
    my $svnroot = get_option ('global', 'svn-server');
    my $module;
    my @modules = grep (!/^(KDE\/)?kde-common$/, @{$build_ref});
    my $result;
    my $outfile = get_output_file ();

    # No reason to print building messages if we're not building.
    return 0 if scalar @modules == 0;

    print "\n<<<  Build Process  >>>\n";

    # Save the environment to keep module's env changes from affecting other
    # modules.
    my %env_backup = %ENV;

    if (pretending)
    {
        print clr "\tWould have opened status file g[$outfile].\n";
        $outfile = undef; # Don't actually try it though.
    }

    if ($outfile)
    {
        open STATUS_FILE, ">$outfile" or do {
            print "\t!Unable to open output status file $outfile\n";
            print "\t$!\n";
            print "\tYou won't be able to use the --resume switch next run.\n";
            $outfile = undef;
        };
    }

    my $num_modules = scalar @modules;
    my $i = 1;

    while ($module = shift @modules)
    {
        my $start_time = time;

        if (build_module ($module, $i, $num_modules))
        {
            my $elapsed = prettify_seconds(time - $start_time);
            print STATUS_FILE "$module: Succeeded after $elapsed.\n" if $outfile;

            print clr "\tOverall time for g[$module] was g[$elapsed].\n";
            push @build_done, $module;
        }
        else
        {
            my $elapsed = prettify_seconds(time - $start_time);
            print STATUS_FILE "$module: Failed after $elapsed.\n" if $outfile;

            print clr "\tOverall time for r[$module] was g[$elapsed].\n";
            push @fail_list, $module;

            if (get_option($module, 'stop-on-failure'))
            {
                print "\n$module didn't build, stopping here.\n";
                return 1; # Error
            }
        }

        print "\n";
        %ENV = %env_backup;
        $i++;
    }

    close STATUS_FILE;

    print "<<<  Build Done  >>>\n";
    print clr "\n<<<  g[PACKAGES SUCCESSFULLY BUILT]  >>>\n" if scalar @build_done > 0;

    if (not pretending)
    {
        # Print out results, and output to a file
        open BUILT_LIST, ">$kdesvn/successfully-built";
        foreach $module (@build_done)
        {
            print "$module\n";
            print BUILT_LIST "$module\n";
        }
        close BUILT_LIST;
    }
    else
    {
        # Just print out the results
        print (clr 'g[', join (clr "]\ng[", @build_done), clr "]\n");
    }

    output_failed_module_list ('failed building', @fail_list);
    return ((scalar @fail_list) > 0) ? 1 : 0;
}

# Subroutine to exit the script cleanly, including removing any
# lock files created.  If a parameter is passed, it is interpreted
# as an exit code to use
sub finish
{
    my $exitcode = shift;
    my $logdir = get_log_dir('global');
    $exitcode = 0 unless $exitcode;

    close_lock();

    print clr "\nYour logs are saved in y[$logdir]\n";
    exit $exitcode;
}

# Subroutine to determine the current repository URL for the current working
# directory.
sub get_repo_url
{
    my $output = `svn info | grep URL`;
    $output =~ s/URL: (.*)$/$1/;
    chomp $output;

    return $output;
}

# Subroutine to handle the installation process.  Simply calls
# 'make install' in the directory.
sub handle_install
{
    my $apidox = pop; # Take parameter off end of list (@_).
    my $result = 0;

    for my $module (@_)
    {
        if ($module =~ /^(qt-copy|kde-common)$/)
        {
            print clr "\tg[$module] doesn't need installed.\n";
            next;
        }

        my $builddir = get_fullpath($module, 'build');

        if (not exists $package_opts{$module})
        {
            print clr "\tUnknown module y[$module], configure it in ~/.kdesvn-buildrc.\n";
            next;
        }

        if (not -e "$builddir" ||
            not -e "$builddir/Makefile")
        {
            print clr "\tThe build system doesn't exist for r[$module].\n";
            print "\tTherefore, we can't install it. :-(.\n";
            next;
        }

        if (pretending)
        {
            print clr "\tWould have installed g[$module]\n";
            next;
        }

        # Just in case, I guess.
        update_module_environment ($module);

        # safe_make() evilly uses the "install" parameter to use installation
        # mode instead of compile mode.  This is so we can get the subdirectory
        # handling for free.
        if (safe_make ($module, "install", $apidox))
        {
            print clr "\tUnable to install r[$module]!\n";
            $result = 1;
            push @install_fail, $module;

            if (get_option($module, 'stop-on-failure'))
            {
                print "Stopping here.\n";
                return 1; # Error
            }
        }
    }

    return $result;
}

# This subroutine goes and makes sure that any entries in the update and build
# lists that have a directory separator are faked into using the checkout-only
# feature.  This doesn't really work for install mode though.
sub munge_lists
{
    print "Munging update and build list\n" if debugging;
    my $cleared = 0;

    for my $list_ref ( ( \@update_list, \@build_list) ) {
        my @temp;
        my %seen;

        while ($_ = shift @$list_ref) {
            # Split at directory separators.
            my ($modulename, @dirs) = split(/\//);

            # For these modules, the first part of the directory separator
            # actually belongs with the module name.
            if (has_base_module($modulename))
            {
                $modulename .= "/" . shift @dirs;
            }

            if (scalar @dirs > 0)
            {
                # Only build the specified subdirs
                if (not $cleared)
                {
                    print "Clearing checkout-only option.\n" if debugging;

                    $cleared = 1;
                    $package_opts{$modulename}{'checkout-only'} = "";
                }

                # The user has included a directory separator in the module name, so
                # let's fake the svn partial checkout
                $_ = $modulename;

                # Don't automatically add the /admin dir for this module now.
                $package_opts{$_}{'#suppress-auto-admin'} = 1;

                my $checkout_str = join ("/", @dirs);

                print "Adding $checkout_str to checkout-only for $_\n" if debugging;

                if (get_option($_, 'checkout-only') !~ /$checkout_str/)
                {
                    $package_opts{$_}{'checkout-only'} .= " $checkout_str";
                }
                else
                {
                    print "\tOption was already present.\n" if debugging;
                }
            }
            else
            {
                print "Skipping $_ in munge process.\n" if debugging;
            }

            # Don't add the modulename to the list twice.  Hashes are the easiest way in
            # Perl to do this.  I'd love an "in" operator for lists.
            push @temp, $_ if not $seen{$_};
            $seen{$_} = 1;
        }

        @$list_ref = @temp;
    }
}

# Script starts.

# Use some exception handling to avoid ucky error messages
eval
{
    # Note to self:  Quit changing the order around.
    process_arguments();       # Process --help, --install, etc. first.
    read_options();            # If we're still here, read the options
    initialize_environment();  # Initialize global env vars.

    setup_logging_subsystem(); # Setup logging directories.

    dump_options() if debugging;
};

if ($@)
{
    # We encountered an error.
    print "Encountered an error in the execution of the script.\n";
    print "The error reported was $@\n";
    print "Please e-mail a bug report to michael.pyne\@kdemail.net\n";
    print "with this information.\n";

    # Don't finish, because we haven't attained the lock yet.
    exit 99;
}

if (not get_lock())
{
    print "$0 is already running!\n";
    exit 0; # Don't finish(), it's not our lockfile!!
}

# Now use an exception trapping loop that calls finish().
my $result;
eval
{
    my $time = localtime;
    print clr "Script started processing at g[$time]\n";

    @update_list = get_update_list();
    @build_list = get_build_list();

    print "Update list is ", join (', ', @update_list), "\n" if debugging;
    print "Build list is ", join (', ', @build_list), "\n" if debugging;

    # Do some necessary adjusting. Right now this is used for supporting
    # the command-line option shortcut to where you can enter e.g.
    # kdelibs/khtml, and the script will only try to update that part of
    # the module.
    munge_lists();

    # Make sure unsermake is checked out automatically if needed
    adjust_update_list(\@update_list, \@build_list);

    if (not $install_flag)
    {
        # No packages to install, we're in build mode
        $result = handle_updates (\@update_list);
        $result = handle_build (\@build_list) || $result;

        output_failed_module_list ("failed to update", @failed_list);
        output_failed_module_list ("failed to install", @install_fail);
    }
    else
    {
        # Installation mode (no apidox)
        $result = handle_install (get_install_list(), 0);

        output_failed_module_list ("failed to install", @install_fail);
    }

    $time = localtime;
    my $color = '';
    $color = 'r[' if $result;

    print clr "${color}Script finished processing at g[$time\n]";
};

if ($@)
{
    # We encountered an error.
    print "Encountered an error in the execution of the script.\n";
    print "The error reported was $@\n";
    print "Please e-mail a bug report to michael.pyne\@kdemail.net\n";
    print "with this information.\n";

    $result = 99;
}

finish($result);

# vim: set et sw=4 ts=4:
